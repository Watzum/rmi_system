%% Basierend auf einer TeXnicCenter-Vorlage von Tino Weinkauf.

\documentclass[a4paper,oneside,10pt]{report}

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}


\usepackage[ngerman]{babel}
\usepackage[T1]{fontenc}
\usepackage[ansinew]{inputenc}
\usepackage[hidelinks]{hyperref}
\hypersetup{
	colorlinks=false,
	allcolors=black
}

\usepackage{lmodern} 

%\usepackage[backend=biber]{biblatex}

%\addbibresource{literatur.bib}

\usepackage{graphicx}

\graphicspath{{images/}}    % Bilderverzeichnis


%% Packages für Formeln %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\usepackage{amsmath}
%\usepackage{amsthm}
%\usepackage{amsfonts}



\begin{document}

\pagestyle{empty} 

\title{Entwicklung eines Remote Method Invocation Systems}
\author{Emil Watz}
\maketitle

\tableofcontents 
\cleardoublepage 

\pagestyle{plain} 



\chapter{Anforderungen an das System}

\section{Verbindung des Server-Objekts mit dem Client-Objekt}

Es kann ein Objekt erstellt werden, deren Funktionen über das Netzwerk aufrufbar sind. Der Client kann sich mit einem Serverobjekt verbinden, damit er dessen Funktionen aufrufen kann. 

\section{Entferntes Aufrufen}

Ein Client soll Funktionen am Server aufrufen können, dieser Funktionsaufruf soll sich aber gleich Verhalten, wie ein lokaler Aufruf. Der Rückgabewert muss also vom Server zurück an den Client gesendet werden. Es können auch Parameter vom Client an den Server mitgegeben werden. Es muss auch eine Lösung für Exceptions geben. 
Außerdem muss ein Verhalten für den Verbindungsabbruch definiert werden. Weiters muss auch beachtet werden, dass Funktionen überladen werden können. 

\subsection{Benutzerdefinierte Typen}

Es können auch, sofern möglich, benutzerdefinierte Typen als Rückgabe- und Parameter verwendet werden, sowohl der Server, als auch der Client müssen natürlich über diesen Typen verfügen. Hierbei muss wieder eine Fehlerbehandlung erfolgen. Die Definition von benutzerdefinierten Typen muss als Protocol Buffer erfolgen!

\section{gRPC-Einsatz}

Der Einsatz von gRPC wird mithilfe einer Konfigurationsklasse realisiert. Diese kann das Verhalten des Server - zum Beispiel die Art oder das Format der Kommunikation - einstellen. 

\section{Optionale Anforderungen}

Eine optionale Anforderung an das System, welche die Bedienung wesentlich erleichtern würde, ist die (teilweise) automatische Generierung des Client-Stubs und des Server-Skeletons. 

\chapter{Umsetzung}

\section{Klassendiagram}

\begin{figure}[h]
\centering
\includegraphics[width=12cm]{class_diagram}
\caption[My Caption]{Klassendiagram des RMI Systems}
\end{figure} 

\subsection{Abstrakte Klasse (AbstractClass)}

Die meisten Remote Method Invocation Systeme verwenden ein Interface, um die Methoden zu definieren. Da es in C++ keine Interfaces gibt, wird daher eine abstrakte Klasse verwendet, welche eine Anzahl an virtuellen ("`virtual"') Funktionen deklariert.

Diese müssen vom Benutzer erstellt werden. Er definiert die Methoden, welche über das Netzwerk aufgerufen werden können. Sowohl der Client, als auch der Server müssen logischerweise die gleiche abstrakte Klasse erweitern. Diese Bedingung muss vom Benutzer selbst erfüllt und überprüft werden, da es keine (einfache) Möglichkeit gibt, die zwei Klassen (übers Netzwerk) in C++ zu vergleichen.
Im Klassendiagramm werden die Beispielfunktionen "`method1"', "`method2"' verwendet

\subsection{Client Stub}

Die \emph{Client Stub}-Klasse erbt von der abstrakten Klasse. Die Implementierungen der virtuellen Funktionen, senden einen Funktionsaufruf an die Skeleton-Klasse des Servers. Den Rückgabewert oder die Exception erhält der Client Stub in serialisierter Form wieder vom Skeleton am Server. 

\subsection{Remote Object}

Das Remote Object enthält ein Template für die Funktion "`sendFunctionCall"', welches die Parameter in einen Protokoll Buffer umwandelt und an das Server-Skeleton sendet. 

\subsection{Skeleton-Klasse am Server}

Die Skeleton-Klasse am Server implementiert die benutzerdefinierte abstrakte Klasse. Die Implementierungen der virtuellen Funktionen wandeln die "`Funktionsaufruf-Nachrichten"', die vom Client Stub gesendet werden, in "`echte"' Funktionsaufrufe der Serverklasse um. Die Rückgabewerte und Exceptions, welche die Funktionen der Serverklasse zurück

\subsection{Serverklasse}

Auch die Serverklasse implementiert die abstrakte Klasse. Die Implementierung der virtuellen Funktionen enthält in dieser Klasse die wirkliche Funktionslogik. 

\subsection{Client}

Der Client ist eine Klasse die komplett vom Benutzer konfiguriert werden kann. Zur Verwendung des Remote Method Invocation System benötigt er eine Instanz des Client Stubs. 

\subsection{Configurator-Klasse} 

Die Configurator-Klasse soll mittel gRPC implementiert werden. Sie soll dem Client ermöglichen, den Server zu konfigurieren und Daten von ihm abzufragen. Zum Beispiel, in dem eingestellt werden kann, dass Exceptions zurückgeliefert werden, oder es können Statistiken abgerufen werden (z.B. die Anzahl der Aufrufe pro Funktion). Ein weiterer potentieller Anwendungsfall ist die Rückgabe der Funktionsnamen, -parameter und -rückgabewerte. Diese können zum Beispiel für die automatische Generierung des Client-Stubs verwendet werden. 
\section{Implementierung des Klassendiagrams}

Nun fehlen aber noch viele wichtige Implementationsdetails. In den nächsten Abschnitten wird ein Konzept wichtiger Teile des Systems näher beschrieben. 

\subsection{Senden des Funktionsaufrufs}

Der Funktionsaufruf muss in irgendeiner Form serialisiert werden. Als Basis bietet sich ein Protokoll Buffer an. Dieser speichert:
\begin{enumerate}
	\item Den Namen des Objekts, dessen Methode aufgerufen wird
	\item Den Namen der Methode, die Aufgerufen wird
	\item Die Parameter, welche mitgeliefert werden
\end{enumerate}

\subsubsection{Serialisierung}

Der letzte Punkt ist bei der Implementierung der schwierigste, da die Anzahl und die Typen der Parameter nicht fix sind. Die Parameter werden daher als JSON-String gespeichert. Die .proto Datei sind danach folgendermaßen aus: 

\begin{lstlisting}
syntax = "proto3";

package examplePkg;

message functionCall {
    required string objectName = 1;
    required string functionName = 1;
    
    optional string parametersInJson = 1;
}
\end{lstlisting}

\subsubsection{Senden der Daten}

Das Erstellen einer Funktion zum Senden der Daten ist wiederum kompliziert, weil die Parameteranzahl variabel ist und der Funktionsname in einen String verwandelt werden muss. Umgesetzt wird das mit einer Superklasse, die jeder Client-Stub erweitern muss. Diese Klasse hat eine Template-Funktion, deren Parametertypen variabel sind und dessen Parameteranzahl beliebig wählbar ist. Der Funktionsname kann durch den Makro \_\_func\_\_ als "`const char array"' übergeben werden. Der Code einer Funktion im Client-Stub könnte folgendermaßen aussehen:

\begin{lstlisting}
class ClientStub : public RemoteObject {
    public: 
    
    void method1(string s, int i) {
        RemoteObject::sendFunctionCall(__func__, s, i);
    }
		
		...
};
\end{lstlisting}

\paragraph{Vereinfachung mithilfe von Makros}

Der Funktionsaufruf der sendFunctionCall Methode kann weiter mit der Definition eines Makros vereinfach werden. Ein Beispielmakro ist Folgender: 

\begin{lstlisting}
// Definition des Makros
#define __SEND_FUNCTION_CALL__(...) return sendFunctionCall(__func__, __VA_ARGS__);

...

//Einsatz des Makros in der Funktion
int method1(int arg1, string arg2) {
	__SEND_FUNCTION_CALL__(arg1, arg2)
}
\end{lstlisting}

\subsubsection{Empfangen des Returnwerts}

Der Rückgabewert, der vom Server wieder an den Client gesendet wird, muss am Client wieder deserialisiert werden. TODO: Konzept entwickeln...

\subsection{Deserialisierung des Funktionsaufrufes}

Für die Umwandlung des Serialisierten Funktionsaufrufes ist die serverseitige Skeleton-Klasse zuständig. Dabei wird mit Makros gearbeitet, um dem Benutzer die Angabe der Funktionen, so weit wie möglich, zu erleichtern. 

Der \_\_FUNCTION\_DEF\_\_ Makro wandelt den Namen der Funktion in einen wirklichen Aufruf um. Außerdem gibt es noch den \_\_ARGUMENT\_\_ Makro, welcher die Parameter \emph{Typ}, welche den Datentyp des Parameters angibt, und \emph{Position}, welche die Position des Parameters angibt (1 => erster Parameter, 2 => zweiter, etc.). Der Datentyp und die Position der Parameter werden benötigt, damit diese aus dem Json-Objekt ausgelesen werden können, welches in dem serialisierten Funktionsaufruf mitgesendet werden. 
Wenn es keinen Parameter gibt, muss der Makro \_\_NO\_ARGUMENTS\_\_ angegeben werden. 

Der folgende Aufruf eines Makros gibt die Funktion method2, mit einem Integer-Parameter an erster Stelle und einem String-Parameter an zweiter, an.

\begin{lstlisting}
__FUNCTION_DEF__(method2, __ARGUMENT__(int, 1), __ARGUMENT__(string, 2));
\end{lstlisting}

Die Definition der Makros sieht folgendermaßen aus: 

\begin{lstlisting}
#define __ARGUMENT__(type, position) jsonObject["parameters"][position].get<type>()
#define __FUNCTION_DEF__(name, ...) if (functionName == #name) name(__VA_ARGS__)
#define __NO_ARGUMENTS__ 
\end{lstlisting}



\addtocontents{toc}{\protect\vspace*{\baselineskip}}

%% Literaturverzeichnis
%% ==> Eine Datei 'literatur.bib' wird hierfür benötigt.
%% ==> Sie müssen hierfür BibTeX verwenden (Projekt | Eigenschaften... | BibTeX)
%\addcontentsline{toc}{chapter}{Literaturverzeichnis}
%\nocite{*} %Auch nicht-zitierte BibTeX-Einträge werden angezeigt.
%\bibliographystyle{alpha} %Art der Ausgabe: plain / apalike / amsalpha / ...
%\bibliography{literatur} %Eine Datei 'literatur.bib' wird hierfür benötigt.

%% Abbildungsverzeichnis
%%\clearpage
%%\addcontentsline{toc}{chapter}{Abbildungsverzeichnis}
%%\listoffigures

%% Tabellenverzeichnis
%%\clearpage
%%\addcontentsline{toc}{chapter}{Tabellenverzeichnis}
%%\listoftables


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% ANHÄNGE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%\appendix
%% ==> Schreiben Sie hier Ihren Text oder fügen Sie externe Dateien ein.

%\input{Dateiname} %Eine Datei 'Dateiname.tex' wird hierfür benötigt.


\end{document}